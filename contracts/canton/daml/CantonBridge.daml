-- Canton-Ethereum Bridge Contract
-- Supports lock/unlock (native Canton tokens) and mint/burn (wrapped Ethereum tokens)
module CantonBridge where

import DA.Optional

-- Asset mode: how tokens are managed on Canton side
data AssetMode = LockUnlock | MintBurn
  deriving (Eq, Show)

-- Simplified CIP-56 token reference
-- In production, integrate with actual CIP-56 contracts
data TokenRef = TokenRef
  with
    issuer : Party
    symbol : Text
  deriving (Eq, Show)

-- Bridge configuration and privileged operations
template Bridge
  with
    operator : Party           -- Bridge operator (relayer)
    tokenRef : TokenRef        -- CIP-56 token being bridged
    mode : AssetMode           -- Lock/unlock or mint/burn
    ethChainId : Int           -- Ethereum chain ID (1 = mainnet, 11155111 = sepolia)
    minAmount : Decimal        -- Minimum transfer amount
    maxAmount : Decimal        -- Maximum transfer amount
  where
    signatory operator
    
    -- Unique bridge per operator and token
    key (operator, tokenRef.symbol, ethChainId) : (Party, Text, Int)
    maintainer key._1
    
    -- User initiates deposit to Ethereum
    choice InitiateDeposit : ContractId DepositRequest
      with
        depositor : Party
        amount : Decimal
        ethRecipient : Text      -- Ethereum address (0x...)
        clientNonce : Text       -- Client-generated unique ID
      controller depositor
      do
        assertMsg "Amount must be positive" (amount > 0.0)
        assertMsg "Amount below minimum" (amount >= minAmount)
        assertMsg "Amount exceeds maximum" (amount <= maxAmount)
        assertMsg "Invalid Ethereum recipient" (not (null ethRecipient))
        
        -- Create deposit request event for relayer to observe
        create DepositRequest
          with
            bridge = self
            operator
            depositor
            tokenRef
            amount
            ethChainId
            ethRecipient
            mode
            clientNonce
    
    -- Operator confirms withdrawal from Ethereum
    choice ConfirmWithdrawal : ContractId WithdrawalReceipt
      with
        ethTxHash : Text         -- Ethereum burn transaction hash
        ethSender : Text         -- Ethereum sender address
        recipient : Party        -- Canton recipient
        amount : Decimal
        nonce : Int
      controller operator
      do
        assertMsg "Amount must be positive" (amount > 0.0)
        assertMsg "Amount below minimum" (amount >= minAmount)
        assertMsg "Amount exceeds maximum" (amount <= maxAmount)
        assertMsg "Invalid Ethereum tx hash" (not (null ethTxHash))
        
        -- Create processed event for replay protection
        create ProcessedEthEvent
          with
            operator
            ethChainId
            txHash = ethTxHash
        
        -- Create withdrawal receipt for user
        create WithdrawalReceipt
          with
            bridge = self
            operator
            recipient
            tokenRef
            amount
            ethChainId
            ethTxHash
            ethSender
            mode
            nonce
    
    -- Pause the bridge (emergency)
    choice Pause : ContractId PausedBridge
      controller operator
      do
        create PausedBridge with bridge = this
    
    -- Update bridge limits
    choice UpdateLimits : ContractId Bridge
      with
        newMinAmount : Decimal
        newMaxAmount : Decimal
      controller operator
      do
        assertMsg "Invalid limits" (newMaxAmount > newMinAmount)
        create this with
          minAmount = newMinAmount
          maxAmount = newMaxAmount

-- Paused bridge (emergency state)
template PausedBridge
  with
    bridge : Bridge
  where
    signatory bridge.operator
    
    choice Unpause : ContractId Bridge
      controller bridge.operator
      do
        create bridge

-- Deposit request event (observed by relayer)
-- Signatory: depositor (who initiated)
-- Observer: operator (who needs to process on Ethereum)
template DepositRequest
  with
    bridge : ContractId Bridge
    operator : Party
    depositor : Party
    tokenRef : TokenRef
    amount : Decimal
    ethChainId : Int
    ethRecipient : Text
    mode : AssetMode
    clientNonce : Text
  where
    signatory depositor
    observer operator
    
    -- Archive after processing (optional)
    choice Acknowledge : ()
      controller operator
      do
        return ()

-- Withdrawal receipt event (confirmation for user)
-- Signatory: operator (who processed)
-- Observer: recipient (who received funds)
template WithdrawalReceipt
  with
    bridge : ContractId Bridge
    operator : Party
    recipient : Party
    tokenRef : TokenRef
    amount : Decimal
    ethChainId : Int
    ethTxHash : Text
    ethSender : Text
    mode : AssetMode
    nonce : Int
  where
    signatory operator
    observer recipient

-- Processed Ethereum event (replay protection)
-- Keyed by (chainId, txHash) to prevent double-processing
template ProcessedEthEvent
  with
    operator : Party
    ethChainId : Int
    txHash : Text
  where
    signatory operator
    
    key (ethChainId, txHash) : (Int, Text)
    maintainer key._1._1.operator
      where
        _1 = operator

-- Token mapping configuration
template TokenMapping
  with
    operator : Party
    cantonToken : TokenRef
    ethTokenAddress : Text     -- Ethereum ERC-20 address
    ethChainId : Int
    mode : AssetMode
    isActive : Bool
  where
    signatory operator
    
    key (operator, cantonToken.symbol, ethChainId) : (Party, Text, Int)
    maintainer key._1
    
    choice DeactivateMapping : ContractId TokenMapping
      controller operator
      do
        create this with isActive = False
    
    choice ActivateMapping : ContractId TokenMapping
      controller operator
      do
        create this with isActive = True
