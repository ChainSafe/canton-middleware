// start all local instances defined in the configuration file
nodes.local.start()

// Bootstrap the synchronizer
bootstrap.synchronizer_local()

// Connect participant1 to da using the connect macro.
// The connect macro will inspect the synchronizer configuration to find the correct URL and Port.
// The macro is convenient for local testing, but obviously doesn't work in a distributed setup.
participant1.synchronizers.connect_local(sequencer1, alias = "da")

// Upload DARs to participant1 - automatically find DAR files in dist directories
// This avoids hardcoding version numbers
import java.io.File

val darDirs = Seq(
  "/canton/contracts/daml/splice-dars",
  "/canton/contracts/daml/common/.daml/dist",
  "/canton/contracts/daml/cip56-token/.daml/dist",
  "/canton/contracts/daml/bridge-core/.daml/dist",
  "/canton/contracts/daml/bridge-wayfinder/.daml/dist"
)

val dars = darDirs.flatMap { dir =>
  val distDir = new File(dir)
  if (distDir.exists && distDir.isDirectory) {
    distDir.listFiles.filter(_.getName.endsWith(".dar")).map(_.getAbsolutePath).toSeq
  } else {
    println(s"Warning: Directory not found: $dir")
    Seq.empty
  }
}

if (dars.isEmpty) {
  println("ERROR: No DAR files found! Run 'daml build' in contracts/canton-erc20/daml first.")
} else {
  println(s"Found ${dars.size} DAR files to upload")
  dars.foreach { darPath =>
    println(s"Uploading $darPath to participant1...")
    try {
      participant1.dars.upload(darPath)
      println(s"Successfully uploaded $darPath")
    } catch {
      case e: Exception => println(s"Failed to upload $darPath: ${e.getMessage}")
    }
  }
}

println("Canton network initialized with DARs uploaded")

val daPort = Option(System.getProperty("canton-examples.da-port")).getOrElse("5001")

// Connect participant2 to da using just the target URL and a local name we use to refer to this particular
// connection. This is actually everything Canton requires and this second type of connect call can be used
// in order to connect to a remote Canton synchronizer.
//
// The connect call is just a wrapper that invokes the `synchronizers.register`, `synchronizers.get_agreement` and `synchronizers.accept_agreement` calls.
//
// The address can be either HTTP or HTTPS. From a security perspective, we do assume that we either trust TLS to
// initially introduce the synchronizer. If we don't trust TLS for that, we can also optionally include a so called
// EssentialState that establishes the trust of the participant to the synchronizer.
// Whether a synchronizer will let a participant connect or not is at the discretion of the synchronizer and can be configured
// there. While Canton establishes the connection, we perform a handshake, exchanging keys, authorizing the connection
// and verifying version compatibility.
participant2.synchronizers.connect("da", s"http://localhost:$daPort")

// The above connect operation is asynchronous. It is generally at the discretion of the synchronizer
// to decide if a participant can join and when. Therefore, we need to asynchronously wait here
// until the participant observes its activation on the synchronizer. As the synchronizer is configured to be
// permissionless in this example, the approval will be granted immediately.
utils.retry_until_true {
    participant2.synchronizers.active("da")
}

participant2.health.ping(participant1)
